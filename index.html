<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Traductor LSC — Minimal</title>

<!-- Minimal elegante CSS interno -->
<style>
  :root{
    --bg:#f5f7fb;
    --card:#ffffff;
    --muted:#64748b;
    --accent:#0ea5a0;
    --accent-2:#0369a1;
    --glass: rgba(255,255,255,0.6);
    --radius:14px;
    --pad:12px;
    --shadow: 0 6px 18px rgba(12,18,31,0.06);
    font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  }

  html,body { height:100%; margin:0; background:linear-gradient(180deg,#f5f7fb 0%, #eef5fa 100%); color:#07123b; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale; }
  .app {
    max-width:980px;
    margin:18px auto;
    padding:18px;
  }

  header { display:flex; gap:12px; align-items:center; justify-content:space-between; margin-bottom:12px; }
  .title { display:flex; gap:12px; align-items:center; }
  .logo {
    width:48px; height:48px; border-radius:10px; background:linear-gradient(135deg,var(--accent),var(--accent-2)); box-shadow: 0 6px 18px rgba(3,105,161,0.14);
    display:flex; align-items:center; justify-content:center; color:#fff; font-weight:700; font-size:20px;
  }
  h1 { margin:0; font-size:18px; letter-spacing:-0.2px; }
  p.lead { margin:0; color:var(--muted); font-size:13px; }

  .grid {
    display:grid;
    grid-template-columns: 1fr 380px;
    gap:16px;
  }

  /* Left panel: camera */
  .card { background:var(--card); border-radius:var(--radius); padding:var(--pad); box-shadow:var(--shadow); }
  .camera-wrap { position:relative; overflow:hidden; border-radius:12px; background:#000; display:flex; align-items:center; justify-content:center; min-height:300px; }
  video#video { width:100%; height:auto; display:block; object-fit:cover; }
  canvas#overlay { position:absolute; left:0; top:0; pointer-events:none; }

  .controls { display:flex; gap:8px; flex-wrap:wrap; margin-top:12px; align-items:center; }
  select, input[type=number] { border-radius:10px; border:1px solid #e6eef8; padding:10px 12px; background:var(--glass); font-size:14px; color:#07203a; }
  button { background:linear-gradient(180deg,var(--accent),var(--accent-2)); color:#fff; border:0; padding:10px 12px; border-radius:10px; cursor:pointer; font-weight:600; box-shadow: 0 6px 16px rgba(3,105,161,0.12); }
  button.ghost { background:transparent; color:var(--accent-2); border:1px solid #d6ecf1; box-shadow:none; }
  .muted { color:var(--muted); font-size:13px; }

  /* Right panel: info + preview */
  .side { display:flex; flex-direction:column; gap:12px; }
  .status { padding:12px; border-radius:10px; background:linear-gradient(180deg,#fff, #fbfdff); border:1px solid #eef6fb; font-size:14px; }
  .counts { font-family:monospace; font-size:13px; color:#0b2b3b; overflow:auto; max-height:120px; padding-right:6px; }
  .preview-grid { display:flex; flex-wrap:wrap; gap:8px; margin-top:8px; }
  .thumb { width:64px; height:64px; border-radius:8px; object-fit:cover; border:1px solid #e9f2f7; box-shadow:0 6px 14px rgba(11,22,35,0.04); }

  footer.note { margin-top:12px; color:var(--muted); font-size:13px; }

  /* Responsive */
  @media (max-width:920px){
    .grid{ grid-template-columns: 1fr; }
    .side { order:2 }
    .camera-wrap { min-height:280px; }
  }

  /* small helpers */
  .small { font-size:13px; color:var(--muted); }
  .row { display:flex; gap:8px; align-items:center; }
  .danger { color:#b91c1c; font-weight:700; }
</style>

<!-- load scripts -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.11.0/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

</head>
<body>
  <div class="app">
    <header>
      <div class="title">
        <div class="logo">LS</div>
        <div>
          <h1>Traductor LSC — alfabeto</h1>
          <p class="lead">Entrena y prueba directamente desde tu celular — modo foto (landmarks)</p>
        </div>
      </div>

      <div class="row">
        <div class="small">Minimal • Entrenamiento en navegador</div>
      </div>
    </header>

    <div class="grid">
      <!-- LEFT: Camera & Actions -->
      <div>
        <div class="card">
          <div class="camera-wrap" aria-hidden="false">
            <video id="video" autoplay playsinline></video>
            <canvas id="overlay"></canvas>
          </div>

          <div class="controls" style="margin-top:14px;">
            <label for="letter" class="small">Clase</label>
            <select id="letter" aria-label="Seleccionar letra"></select>

            <label class="small">Mín muestras</label>
            <input id="minSamples" type="number" value="20" min="1" style="width:86px" />

            <button id="captureSample" title="Capturar muestra">Capturar</button>
            <button id="trainBtn" title="Entrenar modelo">Entrenar</button>
            <button id="predictBtn" title="Predecir frame">Probar</button>
            <button id="realtimeToggle" class="ghost" title="Modo continuo">Real-time</button>
          </div>

          <div class="row" style="margin-top:10px; gap:10px;">
            <button id="saveModelBtn" class="ghost">Guardar</button>
            <button id="loadModelBtn" class="ghost">Cargar</button>
            <button id="exportDataBtn" class="ghost">Exportar</button>
            <button id="importDataBtn" class="ghost">Importar</button>
            <button id="clearDataBtn" class="ghost">Borrar</button>
            <input type="file" id="importFile" style="display:none" accept="application/json" />
          </div>

          <div style="margin-top:12px;" class="small muted">
            <span id="log">Inicializando cámara…</span>
            <div id="progress" style="margin-top:6px;"></div>
          </div>
        </div>
      </div>

      <!-- RIGHT: Status & Preview -->
      <aside class="side">
        <div class="status card">
          <div style="display:flex; justify-content:space-between; align-items:center;">
            <div><strong>Conteos por clase</strong></div>
            <div class="small muted">Selecciona letra para ver miniaturas</div>
          </div>

          <div class="counts" id="counts" aria-live="polite" style="margin-top:8px;">--</div>

          <div style="margin-top:8px;">
            <strong>Preview</strong>
            <div class="preview-grid" id="preview"></div>
          </div>
        </div>

        <div class="status card">
          <div><strong>Consejos rápidos</strong></div>
          <ol style="margin-top:8px; color:var(--muted); font-size:13px; padding-left:16px;">
            <li>Mantén la mano dentro del encuadre.</li>
            <li>Usa fondo claro y buena iluminación.</li>
            <li>Captura variaciones (ángulos / distancia).</li>
            <li>Si usas dos manos, mantenlas separadas y visibles.</li>
          </ol>
        </div>

        <div class="card small">
          <div><strong>Estado:</strong> <span id="statusText">Listo</span></div>
          <div style="margin-top:8px"><strong>Predicción:</strong> <span id="predText">—</span></div>
        </div>

      </aside>
    </div>

    <footer class="note">
      <div class="small muted">Instrucciones: selecciona la letra, presiona <strong>Capturar</strong> varias veces (recomendado ≥20). Luego <strong>Entrenar</strong>. Guarda el modelo si quieres usarlo luego.</div>
    </footer>
  </div>

<script>
/* ------------------ LÓGICA JS (MediaPipe + TFJS) ------------------ */

/* UI elements */
const letters = Array.from(Array(26)).map((_,i)=>String.fromCharCode(65+i));
const selectLetter = document.getElementById('letter');
letters.forEach(l => selectLetter.appendChild(Object.assign(document.createElement('option'), { value: l, text: l })));

const video = document.getElementById('video');
const overlay = document.getElementById('overlay');
const ctx = overlay.getContext('2d');

const captureBtn = document.getElementById('captureSample');
const trainBtn = document.getElementById('trainBtn');
const predictBtn = document.getElementById('predictBtn');
const realtimeBtn = document.getElementById('realtimeToggle');

const saveBtn = document.getElementById('saveModelBtn');
const loadBtn = document.getElementById('loadModelBtn');
const exportBtn = document.getElementById('exportDataBtn');
const importBtn = document.getElementById('importDataBtn');
const importFile = document.getElementById('importFile');
const clearBtn = document.getElementById('clearDataBtn');

const countsEl = document.getElementById('counts');
const previewEl = document.getElementById('preview');
const logEl = document.getElementById('log');
const progressEl = document.getElementById('progress');
const statusText = document.getElementById('statusText');
const predText = document.getElementById('predText');
const minSamplesInput = document.getElementById('minSamples');

let samples = {}; // { 'A': [ { vec: Float32Array(126), thumb: dataUrl }, ... ], ... }
letters.forEach(l => samples[l] = []);
let model = null;
const HAND_POINTS = 21;
const HAND_DIM = HAND_POINTS * 3;
const MAX_HANDS = 2;
const INPUT_DIM = HAND_DIM * MAX_HANDS; // 126
const BATCH_SIZE = 32;
const EPOCHS = 30;

function setLog(t) { logEl.innerText = t; }
function setStatus(t) { statusText.innerText = t; }
function setPred(t) { predText.innerText = t; }

function updateCounts(){
  countsEl.innerText = letters.map(l => `${l}:${samples[l].length}`).join('  •  ');
}
updateCounts();

/* ------------------ MediaPipe Hands ------------------ */
const hands = new Hands({
  locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
});
hands.setOptions({
  maxNumHands: 2,
  modelComplexity: 1,
  minDetectionConfidence: 0.6,
  minTrackingConfidence: 0.6
});
hands.onResults(onHandsResults);

let camera;
async function startCamera(){
  try {
    camera = new Camera(video, {
      onFrame: async () => { await hands.send({image: video}); },
      width: 640,
      height: 480
    });
    await camera.start();
    setLog('Cámara lista — muestra una mano para detectar');
  } catch(e){
    setLog('Error al acceder a la cámara: ' + (e.message || e));
  }
}
startCamera();

/* draw overlay */
function drawLandmarks(multi){
  overlay.width = video.videoWidth || 640;
  overlay.height = video.videoHeight || 480;
  ctx.clearRect(0,0,overlay.width,overlay.height);
  if (!multi || multi.length === 0) return;
  ctx.fillStyle = 'rgba(14,165,160,0.95)';
  for (let h=0; h<multi.length; h++){
    const hand = multi[h];
    for (let i=0;i<hand.length;i++){
      const x = hand[i].x * overlay.width;
      const y = hand[i].y * overlay.height;
      ctx.beginPath(); ctx.arc(x,y,6,0,Math.PI*2); ctx.fill();
    }
  }
}

/* normalize both-hands into Float32Array(126) */
function normalizeMultiLandmarks(multi){
  // multi: array of hands; each hand: 21 {x,y,z}
  if (!multi) return null;
  // sort by wrist x (left->right) to have stable order
  const arr = multi.slice().sort((a,b)=> (a[0].x - b[0].x));
  const combined = [];
  for (let h=0; h<MAX_HANDS; h++){
    const hand = arr[h];
    if (!hand){
      for (let i=0;i<HAND_DIM;i++) combined.push(0);
    } else {
      const base = hand[0];
      const temp = [];
      for (let i=0;i<HAND_POINTS;i++){
        temp.push(hand[i].x - base.x);
        temp.push(hand[i].y - base.y);
        temp.push(hand[i].z - base.z);
      }
      // scale normalize
      let maxAbs = 0;
      for (const v of temp) if (Math.abs(v) > maxAbs) maxAbs = Math.abs(v);
      if (maxAbs === 0) maxAbs = 1e-6;
      for (const v of temp) combined.push(v / maxAbs);
    }
  }
  return Float32Array.from(combined);
}

let lastVector = null;
function onHandsResults(results){
  const multi = results.multiHandLandmarks || [];
  drawLandmarks(multi);
  const v = normalizeMultiLandmarks(multi);
  lastVector = v;
}

/* ------------------ Capture sample (vector + thumb) ------------------ */
captureBtn.addEventListener('click', async () => {
  const label = selectLetter.value;
  if (!lastVector) { setLog('No se detectó mano(s). Asegúrate de que estén visibles.'); return; }

  // thumbnail: draw video center-crop to small canvas
  const tmp = document.createElement('canvas');
  const w = Math.min(160, video.videoWidth || 640);
  const h = Math.min(160, video.videoHeight || 480);
  tmp.width = w; tmp.height = h;
  const tctx = tmp.getContext('2d');
  const sx = Math.max(0, (video.videoWidth - w)/2 || 0);
  const sy = Math.max(0, (video.videoHeight - h)/2 || 0);
  tctx.drawImage(video, sx, sy, w, h, 0, 0, w, h);
  const dataURL = tmp.toDataURL('image/jpeg', 0.75);

  samples[label].push({ vec: Float32Array.from(lastVector), thumb: dataURL });
  updateCounts();
  renderPreviewFor(label);
  setLog(`Muestra guardada para ${label} · total ${samples[label].length}`);
});

/* preview */
selectLetter.addEventListener('change', ()=> renderPreviewFor(selectLetter.value));
function renderPreviewFor(letter){
  previewEl.innerHTML = '';
  const arr = samples[letter] || [];
  for (let i=0;i<arr.length;i++){
    const img = document.createElement('img');
    img.src = arr[i].thumb;
    img.className = 'thumb';
    previewEl.appendChild(img);
  }
}

/* ------------------ Export / Import / Clear ------------------ */
exportBtn.addEventListener('click', () => {
  const payload = { samples: {} };
  for (const k of Object.keys(samples)){
    payload.samples[k] = samples[k].map(s => ({ vec: Array.from(s.vec), thumb: s.thumb }));
  }
  const blob = new Blob([JSON.stringify(payload)], { type:'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'lsc_samples.json'; a.click();
  URL.revokeObjectURL(url);
  setLog('Muestras exportadas (descarga iniciada).');
});

importBtn.addEventListener('click', ()=> importFile.click());
importFile.addEventListener('change', (ev) => {
  const f = ev.target.files[0];
  if (!f) return;
  const r = new FileReader();
  r.onload = () => {
    try {
      const obj = JSON.parse(r.result);
      if (!obj.samples) { setLog('Archivo inválido.'); return; }
      for (const k of Object.keys(obj.samples)) {
        if (!samples[k]) samples[k] = [];
        for (const s of obj.samples[k]) samples[k].push({ vec: Float32Array.from(s.vec), thumb: s.thumb || '' });
      }
      updateCounts(); renderPreviewFor(selectLetter.value);
      setLog('Muestras importadas.');
    } catch(e) { setLog('Error importando archivo.'); }
  };
  r.readAsText(f);
});

clearBtn.addEventListener('click', () => {
  if (!confirm('Borrar todas las muestras de la sesión?')) return;
  letters.forEach(l => samples[l] = []);
  updateCounts(); renderPreviewFor(selectLetter.value);
  setLog('Muestras borradas.');
});

/* ------------------ Build & Train model ------------------ */
function buildModel(numClasses){
  const m = tf.sequential();
  m.add(tf.layers.dense({ inputShape: [INPUT_DIM], units: 256, activation:'relu' }));
  m.add(tf.layers.dropout({ rate: 0.4 }));
  m.add(tf.layers.dense({ units: 128, activation:'relu' }));
  m.add(tf.layers.dropout({ rate: 0.2 }));
  m.add(tf.layers.dense({ units: numClasses, activation:'softmax' }));
  m.compile({ optimizer: tf.train.adam(0.0007), loss: 'categoricalCrossentropy', metrics:['accuracy'] });
  return m;
}

function prepareDataset(){
  const xs = []; const ys = [];
  for (let i=0;i<letters.length;i++){
    const arr = samples[letters[i]];
    for (let j=0;j<arr.length;j++){
      xs.push(Array.from(arr[j].vec));
      const oneHot = new Array(letters.length).fill(0); oneHot[i] = 1;
      ys.push(oneHot);
    }
  }
  if (xs.length === 0) return null;
  const xTensor = tf.tensor2d(xs);
  const yTensor = tf.tensor2d(ys);
  return { x: xTensor, y: yTensor };
}

trainBtn.addEventListener('click', async () => {
  const MIN = Math.max(1, parseInt(minSamplesInput.value || '20'));
  const lacking = letters.filter(l => samples[l].length < MIN);
  if (lacking.length > 0){
    setLog(`No entrenado: faltan muestras (mín ${MIN}) para: ${lacking.slice(0,6).join(', ')}${lacking.length>6? ', ...':''}`);
    setStatus('Muestras insuficientes');
    return;
  }
  const ds = prepareDataset();
  if (!ds) { setLog('No hay datos.'); return; }
  model = buildModel(letters.length);
  setLog('Entrenando en el navegador — esto puede tardar según tu teléfono...');
  setStatus('Entrenando');
  progressEl.innerText = '';
  await model.fit(ds.x, ds.y, {
    epochs: EPOCHS,
    batchSize: Math.min(BATCH_SIZE, Math.max(8, Math.floor(ds.x.shape[0]/4))),
    validationSplit: 0.12,
    callbacks: {
      onEpochEnd: async (epoch, logs) => {
        progressEl.innerText = `Epoch ${epoch+1}/${EPOCHS} — loss:${logs.loss.toFixed(3)} val_loss:${(logs.val_loss||0).toFixed(3)} acc:${(logs.acc||0).toFixed(3)}`;
        await tf.nextFrame();
      }
    }
  });
  ds.x.dispose(); ds.y.dispose();
  setLog('Entrenamiento finalizado. Guarda el modelo si quieres conservarlo.');
  setStatus('Entrenado');
  updateCounts();
});

/* ------------------ Predict & Real-time ------------------ */
predictBtn.addEventListener('click', async () => {
  if (!lastVectorAvailable()) { setLog('No hay landmarks en el frame actual.'); return; }
  if (!model) {
    try { model = await tf.loadLayersModel('indexeddb://lsc-landmarks-model'); setLog('Modelo cargado desde IndexedDB.'); }
    catch(e) { setLog('No hay modelo cargado. Entrena o carga uno primero.'); return; }
  }
  const input = tf.tensor2d([Array.from(lastVector)]);
  const preds = model.predict(input);
  const data = await preds.data();
  const idx = data.indexOf(Math.max(...data));
  const p = letters[idx];
  setLog(`Predicción: ${p} · conf: ${(data[idx]*100).toFixed(1)}%`);
  setPred(`${p} (${(data[idx]*100).toFixed(1)}%)`);
  speak(p);
  input.dispose(); preds.dispose();
});

let realtime = false;
let rtInterval = null;

function lastVectorAvailable(){ return (typeof lastVector !== 'undefined' && lastVector && lastVector.length === INPUT_DIM); }

realtimeBtn.addEventListener('click', async () => {
  realtime = !realtime;
  realtimeBtn.innerText = realtime ? 'Detener real-time' : 'Real-time';
  realtimeBtn.classList.toggle('ghost');
  if (realtime){
    if (!model){
      try { model = await tf.loadLayersModel('indexeddb://lsc-landmarks-model'); setLog('Modelo cargado desde storage para real-time'); }
      catch(e){ setLog('No hay modelo en storage — entrena antes'); realtime=false; realtimeBtn.innerText = 'Real-time'; realtimeBtn.classList.toggle('ghost'); return; }
    }
    rtInterval = setInterval(async () => {
      if (!lastVectorAvailable() || !model) return;
      const input = tf.tensor2d([Array.from(lastVector)]);
      const preds = model.predict(input);
      const data = await preds.data();
      const idx = data.indexOf(Math.max(...data));
      const p = letters[idx];
      setLog(`Real-time → ${p} ${(data[idx]*100).toFixed(1)}%`);
      setPred(`${p} ${(data[idx]*100).toFixed(1)}%`);
      input.dispose(); preds.dispose();
    }, 500);
  } else {
    clearInterval(rtInterval);
    setPred('—');
  }
});

/* ------------------ Save / Load model ------------------ */
saveBtn.addEventListener('click', async () => {
  if (!model) { setLog('No hay modelo para guardar.'); return; }
  try { await model.save('indexeddb://lsc-landmarks-model'); setLog('Modelo guardado en IndexedDB.'); }
  catch(e) { setLog('Error guardando: ' + e); }
});

loadBtn.addEventListener('click', async () => {
  try { model = await tf.loadLayersModel('indexeddb://lsc-landmarks-model'); setLog('Modelo cargado desde IndexedDB.'); setStatus('Modelo cargado'); }
  catch(e) { setLog('No se encontró modelo guardado.'); }
});

/* ------------------ TTS ------------------ */
function speak(text){
  if (!('speechSynthesis' in window)) return;
  const u = new SpeechSynthesisUtterance(text);
  u.lang = 'es-ES';
  window.speechSynthesis.cancel();
  window.speechSynthesis.speak(u);
}

/* ------------------ cleanup ------------------ */
window.addEventListener('beforeunload', () => { if (rtInterval) clearInterval(rtInterval); });

/* expose lastVector to prediction code */
let lastVector = null;
function updateLastVector(vec){ lastVector = vec; }
function getLastVector(){ return lastVector; }

/* Hook: onHandsResults update lastVector */
(function patchOnHands(){
  const orig = onHandsResults;
  window.onHandsResults = function(results){ orig(results); updateLastVector(normalizeMultiLandmarks(results.multiHandLandmarks || [])); };
})();

/* But our hands.onResults already calls onHandsResults, so we also set lastVector in that callback */
function onHandsResults(results){
  const multi = results.multiHandLandmarks || [];
  drawLandmarks(multi);
  const v = normalizeMultiLandmarks(multi);
  lastVector = v;
}
</script>
</body>
</html>